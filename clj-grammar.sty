% see mmm.sty for implementation of newmeta etc

% macros for Clojure grammars
\usepackage{mathpartir}
\usepackage{amsfonts}
\usepackage{bbm}
\usepackage{xcolor}


% newmeta variables are automatically subscripted
% \x0, \x1, \x{}

%% metavariables

% constants
\newmeta\c{c}

% types
\newmeta\s{\sigma}              % these are automatically wrapped in \ma
\newmeta\sp{\sigma{'}}
\newmeta\t{\tau}
\newmeta\tp{\tau{'}}
\newmeta\T{T}

% expressions
\newmeta\M{M}
\newmeta\N{N}
\newmeta\P{P}
\newmeta\e{e}
\newmeta\ep{e'}
\newmeta\expd{d}

% we write a macro for every bit of abstract syntax.  That way they
% will all look the same!

% types
\newbfop\int{int}
\newbfop\Boolean{Boolean}
\newbfop\MultiFn{MultiFn}
\newbfop\IPersistentMapLiteral{IPersistentMap}
\newbfop\Uliteral{\ma{\bigcup}}
\newbfop\Iliteral{\ma{\bigcap}}
\newbfop\Not{Not}
\newbfop\Allliteral{All}
\newbfop\TFnliteral{TFn}
\newbfop\Valueliteral{Value}
\newbfop\ArrayTwoLiteral{Array2}
\newbfop\ArrayLiteral{Array}
\newbfop\ArrayPLiteral{ArrayP}
\newbfop\Throwable{java.lang.Throwable}
\newbfop\Class{java.lang.Class}
\newcommand\proctype[2]{(#1 \to #2)}
\newcommand\Unionsplice[1]{(\ma{\Uliteral\ #1})}
\newcommand\Union[2]{(\ma{\Uliteral\ #1\ #2})}
\newcommand\In[1]{(\ma{\Iliteral\ #1})}
\newcommand\ArrayTwo[2]{(\ma{\ArrayTwoLiteral\ #1\ #2})}
\newcommand\Array[1]{(\ArrayLiteral #1)}
\newcommand\ArrayP[1]{(\ArrayPLiteral #1)}
% \proctype is a little overkill.
%% Reynolds' package can also abstract things like (\s1 \to \s2 \to \s3).
\newcommand\Arrow[4]{\ma{#1 \xrightarrow[#4]{#3} #2}}
% TODO figure out how to make #1 : #2 closer to the :
\newcommand\ArrowOne[5]{\ma{{\hastype {#1} {#2}} \xrightarrow[#5]{#4} #3}}

\newcommand\All[2]{(\ma{\Allliteral\ [#1]\ #2})}
\newcommand\TFn[2]{(\ma{\TFnliteral\ [#1]\ #2})}
\newcommand\Value[1]{(\ma{\Valueliteral\ #1})}
\newbfop\Top{Any}
\newbfop\Bottom{Nothing}
\newbfop\Keyword{Keyword}
\newbfop\Symbol{Symbol}
\newbfop\Number{Number}
\newbfop\Nil{nil}
\newbfop\True{true}
\newbfop\False{false}
\newbfop\falsy{(\ma{\cup\ \Nil\ \False})}
\newbfop\falsydiff{\ma{\trdiff{\falsy}}}
\newcommand\IPersistentMap[2]{(\ma{\IPersistentMapLiteral\ #1\ #2})}
\newbfop\HMapliteral{HMap}
\newcommand\HMapc[1]{(\ma{\HMapliteral^{complete}\ #1})}
\newcommand\HMapp[2]{(\ma{\HMapliteral\ #1\ #2})}
\newcommand\mandatoryset[1]{\ma{\{#1\}}}
\newmeta\mandatory{p}
\newmeta\absent{a}
\newbfop\Satisfiesliteral{Satisfies}
\newcommand\Satisfies[1]{(\ma{\Satisfiesliteral\ #1})}
\newbfop\Instanceliteral{InstanceOf}
\newcommand\Instance[1]{(\ma{\Instanceliteral\ #1})}

% terms
\newmeta\x{x}                   % not sure if \x is reserved...
\newmeta\xp{x{'}}                   % not sure if \x is reserved...
\newmeta\v{v}
\newmeta\class{C}
\newmeta\classp{C{'}}
\newmeta\protocol{P}
\newmeta\k{k}
\newmeta\nil{{\bf nil}}
\newmeta\true{{\bf true}}
\newmeta\false{{\bf false}}
\newmeta\assoc{assoc}
\newmeta\dissoc{dissoc}
\newmeta\get{get}
\newmeta\tryliteral{{\bf try}}
\newmeta\catchliteral{{\bf catch}}
\newmeta\finallyliteral{{\bf finally}}
\newmeta\ifliteral{{\bf if}}
\newmeta\doliteral{{\bf do}}
\newmeta\fnliteral{{\bf fn}}
\newmeta\letliteral{{\bf let}}
\newmeta\throwliteral{{\bf throw}}
\newmeta\newliteral{{\bf new}}
\newmeta\defmultiliteral{{\bf defmulti}}
\newmeta\defmethodliteral{{\bf defmethod}}
\newcommand\abs[2]{\ma{\l #1 . #2}}
\newcommand\curlymap[1]{\ma{\{#1\}}}
\newcommand\comb[2]{\ma{(#1\ #2)}}
\newcommand\tryexp[5]{(\ma{\tryliteral{}\ #1\ (\ma{\catchliteral{}\ #2\ #3\ #4})\ (\ma{\finallyliteral{}\ #5})})}
\newcommand\ifexp[3]{(\ma{\ifliteral{}\ #1\ #2\ #3})}
\newcommand\doexp[2]{(\ma{\doliteral{}\ #1\ #2})}
\newcommand\fnexp[2]{(\ma{\fnliteral{}\ [#1]\ #2})}
\newcommand\letexp[3]{(\ma{\letliteral{}\ [\ma{#1\ #2}]\ #3})}
\newcommand\appexp[2]{(\ma{#1\ #2})}
\newcommand\throwexp[1]{(\ma{\throwliteral{}\ #1})}
\newcommand\newexp[2]{(\ma{\newliteral{}\ #1\ #2})}
\newmeta\dotliteral{.}
\newcommand\fieldexp[2]{(\ma{\dotliteral\ #2\ #1})}
\newcommand\methodexp[3]{(\ma{\dotliteral\ #2\ (#1\ #3)})}
\newcommand\defmultiexp[2]{(\ma{\defmultiliteral{}\ #1\ #2})}
\newcommand\defmethodexp[4]{(\ma{\defmethodliteral{}\ #1\ #2\ [#3]\ #4})}

% Java primitives
\newmeta\pint{int}
\newbfop\Integer{java.lang.Integer}
\newmeta\plong{long}
\newbfop\Long{java.lang.Long}
\newmeta\pdouble{double}
\newbfop\Double{java.lang.Double}
\newmeta\pchar{char}
\newbfop\Character{java.lang.Character}
\newmeta\pvoid{void}
\newbfop\Void{java.lang.Void}
\newmeta\mth{mth}
\newmeta\fld{fld}

% Clojure values
\newmeta\symbol{symbol}
\newmeta\nat{nat}

% constant calls
\newbfop\ccclass{class}
\newbfop\instanceop{instance?}
\newbfop\satisfiesop{satisfies?}
\newbfop\isaop{isa?}
\newcommand\instanceapp[2]{(\instanceop\ #1\ #2)}
\newcommand\satisfiesapp[2]{(\satisfiesop\ #1\ #2)}
\newcommand\isaapp[2]{(\isaop\ #1\ #2)}

% differences from TR
\newcommand\trdiff[1]{\mathbin{\textcolor{blue}{#1}}}

% class table
\newcommand\ct[0]{\mathcal{CT}}
\newcommand\ctlookup[1]{\ct(\ma{#1})}

% typing judgements
\newcommand\hastype[2]{\ma{#1 \mathbin{:} #2}}
\newcommand\hastypesmall[2]{\ma{#1 : #2}}
\newcommand\issubtype[2]{\ma{#1 \mathbin{<:} #2}}
% 4 place relation (TR formalism)
\newcommand\judgement[4]{\ma{#1 \vdash #2\ ;\ #3\ ;\ #4}}
% 7 place relation (TC formalism)
\newcommand\judgementsev[7]{\ma{#1\ ; #2\ ; #3 \vdash_{\trdiff{\ct{}}} #4\ ;\ #5\ ;\ #6\ ;\ #7}}
% 7 place relation with color
\newcommand\judgementsevcol[7]{\judgementsev {\trdiff{#1}} {\trdiff{#2}} {#3} {#4} {#5} {#6} {\trdiff{\mmenv}}}
% expands to 7 place but with 4 args (the TR formalism)
\newcommand\judgementfillcol[4]{\judgementsevcol {\mmenv} {\taenv} {#1} {#2} {#3} {#4} {\mmenv}}
% lookuping props in the env
\newcommand\inpropenv[2]{\ma{#1 \vdash #2}}

% tools.analyzer judgements
\newcommand\ta[0]{\mathcal{TA}}
\newcommand\tajudgement[2]{\ma{#1 \vdash_{\ta{}; {\ct{}}} #2}}

% type hints
\newmeta\classhint{C}
\newmeta\unknownhint{\mathbbm{?}}
\newcommand\hinted[2]{\ma{\widehat{} #1\ #2}}

% convert tools.analyzer types to core.typed types
\newcommand\tatotc[2]{\ma{[[#1]]\ =\ #2}}

% environment
\newcommand\propenv{\Gamma}
\newcommand\mmenv{\Delta}
\newcommand\mmenvp{\Delta'}
\newcommand\taenv{\Gamma'}

% multimethod envs
\newcommand\adddispatchfn[2]{\ma{add\_dispatch\_fn(#1,\ #2)}}
\newcommand\getdispatchfn[2]{\ma{get\_dispatch\_fn(#1)_{#2}}}

% isa? special functions
\newcommand\isacompare[3]{\ma{isa\_compare(#1,\ #2)_{#3}}}

% new special functions
% Type -> [Type]
\newcommand\ctorparams[3]{\ma{constructor(#1,\ #2)\ =\ #3}}

% field special functions
% Type Field -> Type
\newcommand\fieldtype[3]{\ma{field(#1,\ #2)\ =\ #3}}

% method special functions
% Type [Type] Method -> [Type]
\newcommand\methodtype[4]{\ma{method(#1,\ #2)\ =\ [#3, #4]}}

% java subtyping
\newcommand\assignable[2]{\ma{assignable(#1, #2)}}

% evaluation contexts
\newmeta\E{E}


% propositions
\newmeta\prop{\psi}
\newmeta\propp{\psi'}
\newcommand\isprop[2]{\ma{{#1}_{#2}}}
\newcommand\impprop[2]{\ma{#1 \supset #2}}
\newcommand\notprop[2]{\ma{{\overline{#1}}_{#2}}}
\newcommand\andprop[2]{\ma{#1 \wedge #2}}
\newcommand\orprop[2]{\ma{#1 \vee #2}}
\newmeta\topprop{\mathbbm{tt}}
\newmeta\botprop{\mathbbm{ff}}
\newcommand\filterset[2]{\ma{#1 | #2}}
\newcommand\thenprop[1]{\ma{{#1}_+}}
\newcommand\elseprop[1]{\ma{{#1}_-}}
\newcommand\flowprop[1]{\ma{{#1}_\rightarrow}}

% objects
\newcommand\path[2]{\ma{#1(#2)}}
\newmeta\object{o}
\newmeta\objectp{o'}
\newmeta\emptyobject{\emptyset}
\newmeta\pathelem{\pi}
% abstract syntax for pathelem
\newmeta\pesyntax{pe}
\newmeta\classpe{{\bf Class}}
\newmeta\countpe{{\bf Count}}
\newcommand\keype[1]{{\bf Key_{\ma{#1}}}}

% scope replacements
\newcommand\replacefor[3]{\ma{#1 [#2 / #3]}}

% Java type conversion functions
\newcommand\javaspecial[1]{{\bf SpecialToTC}(\ma{#1})}
\newcommand\javatotc[2]{{\bf JavaToTC}(\ma{#1, #2})}
\newcommand\JavaField[1]{{\bf Field}(\ma{#1})}
\newcommand\JavaMethod[2]{{\bf Method}(\ma{#1, #2})}
\newcommand\JavaCtor[2]{{\bf Ctor}(\ma{#1, #2})}
\newcommand\JavaArray[1]{#1[]}
