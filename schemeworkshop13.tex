%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint,10pt]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{mmm}
\usepackage{mathpartir}
\usepackage{clj-grammar}
%\usepackage{url}
%\usepackage[style=alphabetic, sorting=nyt]{biblatex}
%\addbibresource{bibliography.bib}

\usepackage{listings}
\lstset{ %
  language=Lisp,                % choose the language of the code
  columns=fixed,basewidth=.5em,
  basicstyle=\small\ttfamily,       % the size of the fonts that are used for the code
  %numbers=left,                   % where to put the line-numbers
  %numberstyle=\small\ttfamily,      % the size of the fonts that are used for the line-numbers
  %stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
  %numbersep=5pt,                  % how far the line-numbers are from the code
  %backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  %showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  %showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,           % adds a frame around the code
  %tabsize=2,          % sets default tabsize to 2 spaces
  captionpos=t,           % sets the caption-position to bottom
  breaklines=true,        % sets automatic line breaking
  breakatwhitespace=true,    % sets if automatic breaks should only happen at whitespace
  %escapeinside={\%*}{*)},          % if you want to add a comment within your code
}


\usepackage{amsmath}


\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{20yy} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Typed Clojure}
\subtitle{A Practical Type System for Clojure based on Typed Racket}

\authorinfo{Ambrose Bonnaire-Sergeant}
           {}
           {abonnairesergeant@gmail.com}
\authorinfo{Rowan Davies}
           {University of Western Australia}
           {rowan@csse.uwa.edu.au}

\maketitle

\begin{abstract}
Typed Racket has proved to be a valuable starting point for
a gradual type system for Clojure.
Building a similar type system for a new language gives the
designer some flexibility to repurpose and extend features.
This paper gives an overview of Typed Clojure, concentrating
on the extensions and differences from Typed Racket. We also
show where Typed Racket's features were particularly useful
for type checking non-trivial Clojure idioms.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
%\terms
%term1, term2

\keywords
gradual types, Clojure

\section{Typed Clojure}

Typed Clojure is a gradual type system for Clojure, based on the
static portion of Typed Racket.

% what are the goals of Typed Clojure?
% where do they differ from Typed Racket? why?

% Things todo
% - small calculus based on previous TR formalisation
%   that demos the ``flow'' environment & not/intersection type
% - discussion and examples for flow filters
% - discussion on the not/difference type, real code where it helps
% - higher-rank polymorphism, show what it enables (eg. monads)
%   - also show more complicated example, making an extensible
%     type for clojure.core/conj, and why it's not straightforward
% - discussion on limitations of local type inference
% - demonstration of how we check multimethods
% - dealing with array covariance
% - note on how we avoid null-pointer exceptions
% - discussion on why Typed Clojure only uses the ``static'' part
%   of Typed Racket
% - the equality filter problem (and draft solution?), a proposition
%   that knows about binding aliasing. Sounds straightforward?

\section{Contributions}

The main result of this paper is to demonstrate that Typed Racket's design
and implementation is applicable to a practical type system for Clojure
by implementing Typed Clojure.

\section{Higher-rank polymorphism}

Typed Clojure supports f-bounded polymorphism and higher-rank
types.

\section{Using negative filters}

Occurrence typing plays an important role in Typed Racket and Typed Clojure.
By maintaining a \emph{proposition environment} of propositions relating types to
bindings, we can update bindings with more accurate types as programs progress.
It follows that there is some correspondence between propositions and types,
characterised by the \emph{update} function, which takes a type and a proposition
and returns a type which updates the input type using the proposition.

There is a straightforward relationship between ``positive'' propositions and types.
For example 
{\tt (update Number (is Integer 0))}
updates Number by Integer, which is Integer, because Integer <: Number.

The relationship between ``negative'' propositions and types is not always obvious.
A common proposition in Typed Clojure is (! (U nil false) a): the proposition that
local binding ``a'' is \emph{not} of type (U nil false).
This problem is most visible in expressions like {\tt (filter identity coll)}, where
``identity'' has a ``then'' proposition that has negative information: (! (U nil false) 0),
which reads, the 0th argument of identity does not contain (U nil false).



\section{Multimethods}

Clojure provides multimethods which can dispatch on the result of an
arbitrary function, the \emph{dispatch function}. \emph{Methods} are
added to the multimethod
which are associated with a \emph{dispatch value}, which is compared to the
result of apply the dispatch function to the argument passed to the
multimethod. If this comparison unambiguously dispatches to one method,
that method is then called with the current arguments.

Occurrence typing, in particular when extended with paths,
for checking method definitions for arbitrary dispatch functions.

\begin{lstlisting}
(ns example.mm
  (:require 
    [clojure.core.typed :refer [ann]]))

(ann my-mm [Any -> Number])
(defmulti my-mm class)

(defmethod my-mm Float [f] (inc f))
\end{lstlisting}

\begin{lstlisting}
(ann clojure.core/class
  [Any -> (U nil Class)
   :object {:id 0, :path [Class]}])
\end{lstlisting}

\begin{verbatim}
TODO
- example of normal MM usage
- explain descrepency btwn TC syntax and formal
  TR calculs syntax. eg. :object/:filter vs over arrow
\end{verbatim}

\section{Extending occurrence typing}

\begin{figure*}
$$
\begin{altgrammar}
  \expd{}, \e{} &::=& \x\ \alt {\comb {\e{}} {\e{}}} %\alt {\abs {\x a} {\e{}}}
                      \alt \true{} \alt \false{} \alt \nil{}
                      \alt {\tryexp {\e{}} {\class} {\x} {\e{}} {\e{}}}
                      \alt {\ifexp {\e{}} {\e{}} {\e{}}}
                      \alt {\doexp {\e{}} {\e{}}}
                      \alt {\fnexp {\x{}} {\t{}} {\e{}}}
                &\mbox{Expressions} \\ \\
  \s{}, \t{}    &::=& (\class{}\ \overrightarrow{\t{}})
                      \alt (\ma{\Value\ \v})
                      \alt (\cup\ \overrightarrow{\t{}})
                      \alt (\cap\ \overrightarrow{\t{}})
                      \alt (\Not\ \t{})
                      \alt (\All\ [\overrightarrow{\x{}}] \t{})
                      \alt (\TFn\ [\overrightarrow{\x{}}] \t{})
                &\mbox{Types}
%  \c{} &::=& \assoc{} \alt \dissoc{} \alt \get{}
%              &\mbox{Constants}
\end{altgrammar}
$$
\caption{Syntax of Expressions, Types}
\end{figure*}

\begin{figure*}
\begin{mathpar}
\infer [T-Var]
{ \inpropenv {\propenv{}} {\isprop {\x} {\tau}}}
{ \judgement {\propenv{}} {{\hastype {\x{}} {\t{}}}} {{\filterset {{\notprop {\falsy} {\x{}}}} {{\isprop {\falsy} {\x{}}}}}}
             {\emptyobject{}} {\topprop{}}}

\infer [T-True]
{}
{ \judgement {\propenv{}} {{\hastype {\true{}} {\True{}}}} {{\filterset {\topprop{}} {\botprop{}}}} {\emptyobject{}} {\topprop{}}}

\infer [T-False]
{}
{ \judgement {\propenv{}} {{\hastype {\false{}} {\False{}}}} {{\filterset {\botprop{}} {\topprop{}}}} {\emptyobject{}} {\topprop{}}}

\infer [T-Nil]
{}
{ \judgement {\propenv{}} {{\hastype {\nil{}} {\Nil{}}}} {{\filterset {\botprop{}} {\topprop{}}}} {\emptyobject{}} {\topprop{}}}

\infer [T-Do]
{ \judgement {\propenv{}} {{\hastype {\e1} {\t1}}} {{\filterset {\prop{1+}} {\prop2}}} {\object{1}} {{\prop{f1}}}
\\
  \judgement {\propenv{}, \prop{f1}} {{\hastype {\e2} {\t2}}} {{\filterset {\prop3} {\prop4}}} {\object{}} {\prop{f2}}
  }
{ \judgement {\propenv{}} {{\hastype {\doexp {\e1} {\e2}} {\t2}}} {{\filterset {\prop3} {\prop4}}} {\object} 
             {{\andprop {\prop{f1}} {\prop{f2}}}}}

\infer [T-If]

%\infer [T-App]

\end{mathpar}
\caption{Typing Rules}
\end{figure*}

%$$
%\begin{tdisplay}{Evaluation Contexts}
%  \begin{altgrammar}
%    \E{} &::=& [ ] % application rules
%              \alt (\c{}\ \overrightarrow{\v{}}\ \E{}\ \overrightarrow{\exp{}}) % eval arguments left-to-right
%              % map rules
%              \alt \{\overrightarrow{\v{}\ \v{}}\ \E{}\ \exp{}\ \overrightarrow{\exp{}\ \exp{}} \} % key first
%              \alt \{\overrightarrow{\v{}\ \v{}}\ \v{}\ \E{}\ \overrightarrow{\exp{}\ \exp{}} \}   % value next
%              &\mbox{Evaluation Contexts}
%  \end{altgrammar}
%\end{tdisplay}
%$$ 

\section{Java interoperability}

As Clojure supports Java interoperability, Typed Clojure has some
integration with Java's type system. Calls to Java methods from
Clojure can be type checked by Typed Clojure.

We currently do not support Java generics

\subsection{Arrays}

Supporting statically sound interactions with Java arrays is a goal
of Typed Clojure. This is complicated by Java's decision to make
arrays covariant in their argument, a well documented source of static
unsoundness.

Our basic approach is to make our array types \emph{bivariant}. Array types
look like \lstinline|(Array2 w r)| and
are reminiscent of functions or pipes: having a contravariant parameter for input (writing)
and a covariant parameter for output (reading).

Most commonly, an array type is invariant in its parameter; it can
write and read input of the same type.
We can get the same effect by setting our input and output
parameters to the same type. For example, \lstinline|(Array2 Number Number)|
(or equivalently, \lstinline|(Array Number)|)
in Typed Clojure is similar to invariant array types of \lstinline|Number| in languages like Scala.

The biggest gain in using a separate input parameter is the ability
to specify \emph{read-only} arrays. Crucially, our type system features an
explicit bottom type \lstinline|Nothing|, allowing a read-only \lstinline|Number| array
to be of type \lstinline|(Array2 Nothing Number)|.

To realise why defining read-only arrays are useful, we need to examine
what makes array covariance unsound in Java.
Array covariance lets us lie about the type of an array so the consumer
of an array cannot tell the actual type of the array when examining a type
signature.

\begin{verbatim}
...
public static Number[] getNumberArray() {
  Number[] n = new Integer[10];
  return n;
}
...
\end{verbatim}

To the casual consumer \emph{getNumberArray} returns an array that can both
read and write \lstinline|Number|s. However it is clear from the implementation
that attempting to write say a \lstinline|Double| to this array will result
in a runtime error.

\begin{verbatim}
...
Number[] myArray = getNumberArray();
myArray[0] = 1.1;
/* Exception in thread "main" 
   java.lang.ArrayStoreException: 
   java.lang.Double */
...
\end{verbatim}

Notice that this is a runtime error, and Java's type system has not helped
statically prevent it.
This could cause a similar issue for other statically-typed languages offering
interoperability with Java. 

To prevent these sorts of runtime exceptions in Typed Clojure, we declare
all arrays from unknown sources to be \emph{read-only}. Put differently,
the only way to define a writeable array is to create it in type-checked Clojure
code.

\begin{lstlisting}
(let [n (CovariantArray/getNumberArray)]
  (aset n 0 1.1))

; Polymorphic static method clojure.lang.RT/aset could not be 
; applied to arguments:
; Domains: 
;         (Array2 i o) clojure.core.typed/AnyInteger i
; 
; Arguments:
;         (Array2 Nothing java.lang.Number) int (Value 1.1)
; 
; with expected type:
;         Any
\end{lstlisting}

The type inferred for the local \lstinline|n| is \lstinline|(Array2 Nothing Number)|
which tells the type system: it is never safe to write to this array, but
it is safe to assume \lstinline|Number|s can be read from this array.

To emphasise, this is a static type error. Errors like this help Clojure programmers
use foreign Java libraries more correctly.

\begin{verbatim}
Note that Java libraries are often large 
and complex and programmers will probably
enjoy the extra help from the type system.
\end{verbatim}

\subsection{Handling null}

Probably the most common pain point in Java programming is dealing with \emph{null}.
It is crucial that Typed Clojure deals with \emph{null} intelligently so that
all potentially erroneous interactions with \emph{null} in typed code are caught at compile time.
We also want to represent \emph{null} in a way that is natural to Clojure programmers
and approximates their mental model when reasoning about Clojure code.

Firstly, we separate the concepts of \emph{null} and reference types at the type level.
This is unlike Java, where a reference type, like \emph{java.lang.Number}, includes \emph{null}.
We provide a singleton type \lstinline|nil|, which contains just the value \lstinline|nil|,
Clojure's equivalent of \emph{null}. 

Armed with general unions and the type \lstinline|nil|, 
we make Typed Clojure's reference types \emph{non-nullable}.
A Java type like \emph{java.lang.Number} is written \lstinline|(U nil java.lang.Number)|
in Typed Clojure.

Typed Racket already provides what is needed to write such types; indeed this is a repurposing
of a common Typed Racket idiom of approximating an Option or Maybe type by
making a union that includes \emph{\#f}, Racket's only false value.
However, like handling covariant arrays, the subtlety lies in our interactions with foreign
Java code.

A set of conversion rules define how to convert a Java type signature into a null-safe
Clojure version. These rules are designed to be conservative and can be explicitly overridden
by programmers. Method parameters are non-nullable, while return types are nullable.
Field types are nullable. Constructor parameters are non-nullable, and return types
are also non-nullable: it is a Java invariant that all constructors return an instance
of the class they are constructing.

\begin{verbatim}
TODO 
- write conversion rules for 
  Java type -> Clojure type
\end{verbatim}

%\appendix
%\section{Appendix Title}
%
%This is the text of the appendix, if you need one.

%\acks
%
%Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

%\bibliographystyle{abbrvnat}
%
%% The bibliography should be embedded for final submission.
%
%\begin{thebibliography}{}
%\softraggedright
%
%\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%P. Q. Smith, and X. Y. Jones. ...reference text...
%
%\end{thebibliography}


\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices

